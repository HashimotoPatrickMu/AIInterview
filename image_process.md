HOG: Histogram of Oriented Gradients, 

> The distribution (histograms) of directions (orientations) of gradients (edge directions) in localized portions of the image. 

RGB has color space while RAW does not. 

---

## Image Denoising

> Mean Filter
>
> > $$
> > \begin{align}
> > \hat{f}(x,y)=\frac{1}{mn}\sum_{(s,t)\in\mathbb{S}_{xy}}g(s,t)
> > \end{align}
> > $$
> >
> > where,
> >
> > - $g(\cdot)$ is the pixels of an image.
>
> Median Filter
>
> > $$
> > \begin{align}
> > \hat{f}(x,y) = \text{median}\{g(s,t) \mid (s,t) \in \mathbb{S}_{xy}\}
> > \end{align}
> > $$
>
> Gaussian Blur
>
> > $$
> > \begin{align}
> > G(x,y) = \frac{1}{2\pi\sigma^2} \exp\left(-\frac{x^2 + y^2}{2\sigma^2}\right)
> > \end{align}
> > $$
> >
> > The Gaussian kernel generated by this function is then convolved with the image to produce the blurred effect. The kernel size and the value of \(\sigma\) determine the degree of blurring.
>
> Wavelet Transform
>
> > continuous, 
> > $$
> > \begin{align}
> > CWT(a,b) = \frac{1}{\sqrt{|a|}} \int_{-\infty}^{\infty} f(t) \psi\left(\frac{t-b}{a}\right) dt
> > \end{align}
> > $$
> > discrete, 
> > $$
> > \begin{align}
> > DWT_{jk} = \sum_{n} f[n] \cdot \psi_{jk}[n]
> > \end{align}
> > $$
> > where, 
> >
> > - $\psi(\cdot)$ is the wavelet function.
>
> non-local means
>
> deep learning

---

## Image Enhancement

> Histogram Equalization
>
> > $$
> > \begin{align}
> > s_k = \text{round}\left(\frac{(L-1) \cdot \text{CDF}(r_k)}{\text{max}(\text{CDF})}\right)
> > \end{align}
> > $$
> >
> > where, 
> >
> > - $L$ is the number of possible intensity levels, 
> > - $\text{CDF}(r_k)$ is the CDF for intensity level $r_k$, 
> > - $\text{max}(\text{CDF})$ ensures normalization by the maximum CDF value.
>
> Adaptive Histogram Equalization
>
> > It divides the image into patches and applies Histogram Equalization on each, then mitigates the boundaries to avoid the abrupt difference. 
>
> Gamma Correction
>
> > $$
> > \begin{align}
> > I_{\text{gamma}} = I_{\text{img}}^\gamma 
> > \end{align}
> > $$
> >
> > where,
> >
> > - $I$ is the pixel intensity, normalized into $[0,1]$
> > - $\gamma$ defines the curve for mapping
>
> Unsharp Masking <a id="anchor-0"></a>
>
> > $$
> > \begin{align}
> > I_{\text{sharpened}} = I_{\text{img}}+\alpha\cdot(I_{\text{img}} -I_{\text{blur}})
> > \end{align}
> > $$
> >
> > where, 
> >
> > - $I_{\text{blur}}$â€‹ is the pixel intensity of the blurred image, 
> > - $\alpha$ is the scaling factor. 
>
> High Boost Filtering
>
> > Refer to <a href="#anchor-0">Unsharp Masking</a>.

---

## Edge Detection Operators

> Sobel Operator
>
> > To detect the edge, more sensitive to the diagonal edge. 
> > $$
> > \begin{align}
> > G_x = 
> > \begin{bmatrix}
> > -1 & 0 & 1 \\
> > -2 & 0 & 2 \\
> > -1 & 0 & 1
> > \end{bmatrix} \ast A, 
> > \quad 
> > G_y = \begin{bmatrix}
> > -1 & -2 & -1 \\
> > 0 & 0 & 0 \\
> > 1 & 2 & 1
> > \end{bmatrix} * A
> > \end{align}
> > $$
> > where,
> >
> > - $A$ is the input image,
> > - and $G_x$ and $G_y$ are the outputs represent the horizontal and vertical edge responses
>
> Scharr Operator
>
> > To detect the rotation symmetry. 
> > $$
> > \begin{align}
> > G_x = \begin{bmatrix}
> > -3 & 0 & 3 \\
> > -10 & 0 & 10 \\
> > -3 & 0 & 3
> > \end{bmatrix} * A, \quad G_y = \begin{bmatrix}
> > -3 & -10 & -3 \\
> > 0 & 0 & 0 \\
> > 3 & 10 & 3
> > \end{bmatrix} * A
> > \end{align}
> > $$
>
> Prewitt Operator
>
> > To detect the edge, more sensitive to horizontal and vertical edges. 
> > $$
> > \begin{align}
> > G_x = \begin{bmatrix}
> > -1 & 0 & 1 \\
> > -1 & 0 & 1 \\
> > -1 & 0 & 1
> > \end{bmatrix} * A, \quad
> > G_y = \begin{bmatrix}
> > -1 & -1 & -1 \\
> > 0 & 0 & 0 \\
> > 1 & 1 & 1
> > \end{bmatrix} * A
> > \end{align}
> > $$
>
> canny edge detector
>
> laplacian of gaussian

---

## Implementation

> [Mosaic Algorithm](implementations/filters/mosaic.py)
>
> [Gaussian Blur](implementations/filters/gaussian_blur.py)
>
> [Average & Median Filter](implementations/filters/average_median.py)

